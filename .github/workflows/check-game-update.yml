name: Check Game Update

on:
  workflow_dispatch:
    inputs:
      game_type:
        description: 'æ¸¸æˆç‰ˆæœ¬ç±»å‹'
        required: true
        default: 'stable'
        type: choice
        options:
          - ea
          - stable
      ea_password:
        description: 'EAç‰ˆå¯†ç ï¼ˆä»…EAç‰ˆéœ€è¦ï¼‰'
        required: false
        type: string
      force_update:
        description: 'å¼ºåˆ¶æ›´æ–°ï¼ˆå¿½ç•¥ç‰ˆæœ¬ç¼“å­˜ï¼‰'
        required: false
        default: false
        type: boolean
  schedule:
    - cron: '0 */6 * * *'  # æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼ˆä»…æ£€æŸ¥ç¨³å®šç‰ˆï¼‰

jobs:
  check_update:
    runs-on: ubuntu-latest
    outputs:
      has_update: ${{ steps.check.outputs.has_update }}
      version: ${{ steps.check.outputs.version }}
      upload_id: ${{ steps.check.outputs.upload_id }}
      build_id: ${{ steps.check.outputs.build_id }}
      game_type: ${{ steps.check.outputs.game_type }}
      android_upload_id: ${{ steps.check.outputs.android_upload_id }}
      android_build_id: ${{ steps.check.outputs.android_build_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests

      - name: Restore version cache
        id: cache
        uses: actions/cache@v4
        with:
          path: .version_cache
          key: game-version-cache-${{ github.event.inputs.game_type || 'stable' }}
          restore-keys: |
            game-version-cache-

      - name: Check for updates
        id: check
        env:
          GAME_TYPE: ${{ github.event.inputs.game_type || 'stable' }}
          FORCE_UPDATE: ${{ github.event.inputs.force_update || 'false' }}
          ITCH_API_KEY: ${{ secrets.ITCH_API_KEY }}
          EA_PASSWORD: ${{ github.event.inputs.ea_password }}
        run: |
          python << 'EOF'
          import os
          import json
          import requests

          # é…ç½®
          STABLE_GAME_ID = "2151565"
          EA_GAME_ID = "2499529"
          UPLOADS_URL = "https://api.itch.io/games/{game_id}/uploads"
          API_KEY = os.environ.get("ITCH_API_KEY", "")
          EA_PASSWORD = os.environ.get("EA_PASSWORD", "")

          game_type = os.environ.get("GAME_TYPE", "stable")
          force_update = os.environ.get("FORCE_UPDATE", "false").lower() == "true"
          game_id = EA_GAME_ID if game_type == "ea" else STABLE_GAME_ID

          print(f"æ£€æŸ¥æ¸¸æˆæ›´æ–°: {game_type} (game_id: {game_id})")
          if force_update:
              print("âš ï¸ å¼ºåˆ¶æ›´æ–°æ¨¡å¼å·²å¯ç”¨")

          if not API_KEY:
              print("âš ï¸ è­¦å‘Š: ITCH_API_KEYæœªè®¾ç½®")
          
          if game_type == "ea" and not EA_PASSWORD:
              print("âŒ é”™è¯¯: EAç‰ˆéœ€è¦æä¾›å¯†ç ")
              exit(1)

          # è·å–ä¸Šä¼ åˆ—è¡¨ - ä½¿ç”¨Headerè®¤è¯
          url = UPLOADS_URL.format(game_id=game_id)
          headers = {"Authorization": API_KEY} if API_KEY else {}
          params = {"password": EA_PASSWORD} if game_type == "ea" and EA_PASSWORD else {}
          
          response = requests.get(url, headers=headers, params=params)
          response.raise_for_status()
          data = response.json()

          # æŸ¥æ‰¾HTML channel
          html_upload = None
          android_upload = None
          for upload in data.get("uploads", []):
              channel = upload.get("channel_name", "")
              if channel == "html":
                  html_upload = upload
              elif channel == "android":
                  android_upload = upload

          if not html_upload:
              print("æœªæ‰¾åˆ°HTML channel")
              exit(1)

          upload_id = html_upload.get("id")
          build_info = html_upload.get("build", {})
          build_id = build_info.get("id")
          version = build_info.get("user_version", str(build_info.get("version", "unknown")))

          print(f"HTML Upload ID: {upload_id}")
          print(f"HTML Build ID: {build_id}")
          print(f"Version: {version}")

          # Android APKä¿¡æ¯
          android_upload_id = ""
          android_build_id = ""
          if android_upload:
              android_upload_id = str(android_upload.get("id", ""))
              android_build_info = android_upload.get("build", {})
              android_build_id = str(android_build_info.get("id", ""))
              print(f"Android Upload ID: {android_upload_id}")
              print(f"Android Build ID: {android_build_id}")
          else:
              print("âš ï¸ æœªæ‰¾åˆ°Android channel")

          # ç‰ˆæœ¬ç¼“å­˜æ–‡ä»¶
          os.makedirs(".version_cache", exist_ok=True)
          version_file = f".version_cache/last_version_{game_type}.json"
          
          # è¯»å–ä¸Šæ¬¡ç¼“å­˜çš„ç‰ˆæœ¬
          last_version = None
          last_build_id = None
          if os.path.exists(version_file):
              try:
                  with open(version_file, "r") as f:
                      cached = json.load(f)
                      last_version = cached.get("version")
                      last_build_id = cached.get("build_id")
                  print(f"ä¸Šæ¬¡ç¼“å­˜ç‰ˆæœ¬: {last_version} (build_id: {last_build_id})")
              except Exception as e:
                  print(f"è¯»å–ç¼“å­˜å¤±è´¥: {e}")

          # æ£€æŸ¥æ˜¯å¦æœ‰æ–°ç‰ˆæœ¬
          has_update = "false"
          if force_update:
              has_update = "true"
              print("âœ… å¼ºåˆ¶æ›´æ–°")
          elif last_build_id is None:
              has_update = "true"
              print("âœ… é¦–æ¬¡è¿è¡Œï¼Œéœ€è¦æ›´æ–°")
          elif str(build_id) != str(last_build_id):
              has_update = "true"
              print(f"âœ… æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬: {last_version} -> {version}")
          else:
              print(f"â„¹ï¸ ç‰ˆæœ¬æœªå˜åŒ–: {version}")

          # ä¿å­˜å½“å‰ç‰ˆæœ¬åˆ°ç¼“å­˜
          with open(version_file, "w") as f:
              json.dump({
                  "version": version,
                  "build_id": build_id,
                  "upload_id": upload_id
              }, f)
          print(f"ç‰ˆæœ¬ä¿¡æ¯å·²ç¼“å­˜åˆ°: {version_file}")
          
          # è¾“å‡ºåˆ°GitHub Actions
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"has_update={has_update}\n")
              f.write(f"version={version}\n")
              f.write(f"upload_id={upload_id}\n")
              f.write(f"build_id={build_id}\n")
              f.write(f"game_type={game_type}\n")
              f.write(f"android_upload_id={android_upload_id}\n")
              f.write(f"android_build_id={android_build_id}\n")
          
          print(f"\n{'ğŸš€ å°†æ‰§è¡Œæ›´æ–°' if has_update == 'true' else 'â­ï¸ è·³è¿‡æ›´æ–°'}")
          EOF

      - name: Save version cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .version_cache
          key: game-version-cache-${{ github.event.inputs.game_type || 'ea' }}-${{ github.run_id }}

  download_and_export:
    needs: check_update
    if: needs.check_update.outputs.has_update == 'true'
    runs-on: windows-latest
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
      UPLOAD_ID: ${{ needs.check_update.outputs.upload_id }}
      BUILD_ID: ${{ needs.check_update.outputs.build_id }}
      PYTHONIOENCODING: utf-8
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests selenium webdriver-manager

      - name: Setup Chrome
        uses: browser-actions/setup-chrome@latest

      - name: Download HTML file
        shell: bash
        run: |
          python << 'EOF'
          import os
          import requests

          upload_id = os.environ["UPLOAD_ID"]
          build_id = os.environ["BUILD_ID"]
          version = os.environ["VERSION"]

          html_url = f"https://html-classic.itch.zone/html/{upload_id}-{build_id}/index.html"
          print(f"ä¸‹è½½HTML: {html_url}")

          response = requests.get(html_url, stream=True)
          response.raise_for_status()

          os.makedirs("temp_update_files", exist_ok=True)
          html_path = f"temp_update_files/index{version}.html"
          
          with open(html_path, "wb") as f:
              for chunk in response.iter_content(chunk_size=8192):
                  f.write(chunk)
          
          print(f"HTMLå·²ä¿å­˜åˆ°: {html_path}")
          
          # ä¿å­˜è·¯å¾„ä¾›åç»­æ­¥éª¤ä½¿ç”¨
          with open(os.environ["GITHUB_ENV"], "a") as f:
              f.write(f"HTML_PATH={os.path.abspath(html_path)}\n")
          EOF

      - name: Export story data
        shell: bash
        run: |
          python << 'EOF'
          import os
          import time
          from selenium import webdriver
          from selenium.webdriver.chrome.service import Service as ChromeService
          from webdriver_manager.chrome import ChromeDriverManager
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC

          html_path = os.environ["HTML_PATH"]
          version = os.environ["VERSION"]
          
          # æ£€æŸ¥story-export.jsæ˜¯å¦å­˜åœ¨
          js_path = "story-export.js"
          if not os.path.exists(js_path):
              print(f"è­¦å‘Š: {js_path} ä¸å­˜åœ¨ï¼Œè·³è¿‡æµè§ˆå™¨è‡ªåŠ¨åŒ–æ­¥éª¤")
              print("è¯·ç¡®ä¿story-export.jsæ–‡ä»¶å·²æ·»åŠ åˆ°ä»“åº“ä¸­")
              exit(0)

          # é…ç½®Chrome headless
          options = webdriver.ChromeOptions()
          options.add_argument("--headless=new")
          options.add_argument("--no-sandbox")
          options.add_argument("--disable-dev-shm-usage")
          options.add_argument("--disable-gpu")
          
          download_dir = os.path.abspath(".")
          prefs = {
              "download.default_directory": download_dir,
              "download.prompt_for_download": False,
              "download.directory_upgrade": True,
              "safebrowsing.enabled": True
          }
          options.add_experimental_option("prefs", prefs)

          driver = None
          try:
              service = ChromeService(ChromeDriverManager().install())
              driver = webdriver.Chrome(service=service, options=options)
              
              # headlessæ¨¡å¼ä¸‹è®¾ç½®ä¸‹è½½è¡Œä¸º
              driver.execute_cdp_cmd("Page.setDownloadBehavior", {
                  "behavior": "allow",
                  "downloadPath": download_dir
              })
              
              driver.get("file://" + html_path)
              
              WebDriverWait(driver, 10).until(
                  EC.presence_of_element_located((By.TAG_NAME, "body"))
              )
              print("é¡µé¢å·²åŠ è½½")

              with open(js_path, "r", encoding="utf-8") as f:
                  js_code = f.read()
              
              print("æ‰§è¡Œå¯¼å‡ºè„šæœ¬...")
              driver.execute_script(js_code)
              
              # ç­‰å¾…ä¸‹è½½å®Œæˆ
              zip_path = os.path.join(download_dir, "story_export.zip")
              timeout = 60
              start_time = time.time()
              while not os.path.exists(zip_path):
                  time.sleep(1)
                  if time.time() - start_time > timeout:
                      print("ä¸‹è½½è¶…æ—¶")
                      exit(1)
              
              print(f"å¯¼å‡ºå®Œæˆ: {zip_path}")

          except Exception as e:
              print(f"é”™è¯¯: {e}")
              exit(1)
          finally:
              if driver:
                  driver.quit()
          EOF

      - name: Upload HTML artifact
        uses: actions/upload-artifact@v4
        with:
          name: game-html-${{ env.VERSION }}
          path: temp_update_files/*.html
          if-no-files-found: warn

      - name: Upload story export artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: story-export-${{ env.VERSION }}
          path: story_export.zip
          if-no-files-found: warn

  inject_modloader:
    needs: [check_update, download_and_export]
    if: needs.check_update.outputs.has_update == 'true'
    runs-on: windows-latest
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
      PYTHONIOENCODING: utf-8
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download HTML artifact
        uses: actions/download-artifact@v4
        with:
          name: game-html-${{ env.VERSION }}
          path: game-html

      - name: Use Node.js 18.x
        uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Download ModLoader Package from workflow artifact
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          repo: Lyoko-Jeremie/sugarcube-2-ModLoader
          workflow: Build-ModLoader-Package.yml
          workflow_conclusion: success
          name: ModLoader Package
          path: modloader-download
          search_artifacts: true

      - name: Setup ModLoader Package
        shell: pwsh
        run: |
          Write-Host "=== Downloaded files in modloader-download (top level) ==="
          Get-ChildItem -Path "modloader-download" | ForEach-Object { Write-Host $_.Name }
          
          # æ£€æŸ¥ dist-insertTools æ˜¯å¦ç›´æ¥åœ¨ modloader-download ä¸­
          if (Test-Path "modloader-download/dist-insertTools") {
            Write-Host ""
            Write-Host "dist-insertTools found directly in modloader-download"
            Write-Host "Renaming modloader-download to ml-package..."
            Rename-Item -Path "modloader-download" -NewName "ml-package"
          } else {
            Write-Host "ERROR: dist-insertTools not found in modloader-download"
            Write-Host "Full contents:"
            Get-ChildItem -Path "modloader-download" -Recurse | Select-Object -First 50 | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }
          
          Write-Host ""
          Write-Host "=== ml-package contents ==="
          Get-ChildItem -Path "ml-package" | ForEach-Object { Write-Host $_.Name }
          
          # éªŒè¯å…³é”®ç›®å½•
          if (Test-Path "ml-package/dist-insertTools") {
            Write-Host "âœ“ dist-insertTools OK"
          } else {
            Write-Host "âœ— dist-insertTools MISSING"
            exit 1
          }
          
          if (Test-Path "ml-package/dist-BeforeSC2") {
            Write-Host "âœ“ dist-BeforeSC2 OK"
          } else {
            Write-Host "âœ— dist-BeforeSC2 MISSING"
            exit 1
          }

      - name: Checkout SugarCube-2
        uses: actions/checkout@v4
        with:
          repository: Lyoko-Jeremie/sugarcube-2_Vrelnir
          path: SC2
          ref: TS2

      - name: Build SugarCube-2
        working-directory: ${{ github.workspace }}/SC2
        run: |
          npm install
          node build.js -d -u -b 2

      - name: Copy SC2 format.js
        shell: bash
        run: |
          cp SC2/build/twine2/sugarcube-2/format.js ml-package/format.js
          echo "Copied format.js to ml-package/"
          ls -la ml-package/format.js

      - name: Get ModLoader version
        id: modloader_version
        shell: bash
        run: |
          # ä» dist-BeforeSC2/Utils.js ä¸­æå–ç‰ˆæœ¬å·
          UTILS_FILE="ml-package/dist-BeforeSC2/Utils.js"
          
          echo "Looking for: $UTILS_FILE"
          if [ -f "$UTILS_FILE" ]; then
            echo "Found Utils.js"
            # æå–ç‰ˆæœ¬å· - ç®€åŒ–æ­£åˆ™
            ML_VERSION=$(grep -oE "[0-9]+\.[0-9]+\.[0-9]+" "$UTILS_FILE" | head -1)
            echo "Extracted version: $ML_VERSION"
          else
            echo "Utils.js not found, searching..."
            find ml-package -name "Utils.js" -type f
          fi
          
          if [ -z "$ML_VERSION" ]; then
            ML_VERSION="unknown"
          fi
          
          echo "ModLoader Version: v$ML_VERSION"
          echo "MODLOADER_VERSION=v$ML_VERSION" >> $GITHUB_ENV

      - name: Copy modList.json
        shell: bash
        run: |
          cp modloader/modList.json ml-package/modList.json
          echo "Copied modList.json to ml-package/"

      - name: Find and set HTML filename
        shell: bash
        run: |
          HTML_FILE=$(ls game-html/*.html | head -1)
          HTML_BASENAME=$(basename "$HTML_FILE")
          echo "HTML_FILE=$HTML_FILE" >> $GITHUB_ENV
          echo "HTML_BASENAME=$HTML_BASENAME" >> $GITHUB_ENV
          echo "Found HTML file: $HTML_FILE"

      - name: SC2 Replace
        shell: pwsh
        working-directory: ${{ github.workspace }}/ml-package
        run: |
          $htmlPath = "${{ github.workspace }}/${{ env.HTML_FILE }}"
          $formatPath = Get-ChildItem -Path "." -Filter "format.js" -Recurse | Select-Object -First 1
          if ($formatPath) {
            Write-Host "Using format.js: $($formatPath.FullName)"
            node "dist-insertTools/sc2ReplaceTool.js" $htmlPath $formatPath.FullName
          } else {
            Write-Host "format.js not found, skipping SC2 replace"
            Copy-Item $htmlPath "$htmlPath.sc2replace.html"
          }

      - name: Inject ModLoader
        shell: pwsh
        working-directory: ${{ github.workspace }}/ml-package
        run: |
          $htmlPath = "${{ github.workspace }}/${{ env.HTML_FILE }}.sc2replace.html"
          node "dist-insertTools/insert2html.js" $htmlPath "modList.json" "dist-BeforeSC2/BeforeSC2.js" ""

      - name: Inject ModLoader (polyfill)
        shell: pwsh
        working-directory: ${{ github.workspace }}/ml-package
        run: |
          $htmlPath = "${{ github.workspace }}/${{ env.HTML_FILE }}.sc2replace.html"
          $polyfillPath = "dist-BeforeSC2/polyfill.js"
          if (Test-Path $polyfillPath) {
            node "dist-insertTools/insert2html-polyfill.js" $htmlPath "modList.json" "dist-BeforeSC2/BeforeSC2.js" $polyfillPath "ManualPolyfill.js"
          } else {
            Write-Host "polyfill.js not found, skipping polyfill injection"
          }

      - name: Apply CoT specific patches
        shell: bash
        run: |
          MOD_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod.html"
          POLYFILL_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod-polyfill.html"
          
          if [ -f "$MOD_HTML" ]; then
            python modloader/replace.py "$MOD_HTML"
          fi
          
          if [ -f "$POLYFILL_HTML" ]; then
            python modloader/replace.py "$POLYFILL_HTML"
          fi

      - name: Prepare final output
        shell: bash
        run: |
          mkdir -p final-output
          
          MOD_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod.html"
          POLYFILL_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod-polyfill.html"
          GAME_VER="${VERSION}"
          ML_VER="${MODLOADER_VERSION}"
          
          if [ -f "$MOD_HTML" ]; then
            cp "$MOD_HTML" "final-output/CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}.html"
            echo "Created: CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}.html"
          fi
          
          if [ -f "$POLYFILL_HTML" ]; then
            cp "$POLYFILL_HTML" "final-output/CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}-polyfill.html"
            echo "Created: CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}-polyfill.html"
          fi
          
          ls -la final-output/

      - name: Upload ModLoader injected HTML
        uses: actions/upload-artifact@v4
        with:
          name: CourseOfTemptation-ModLoader-${{ env.VERSION }}-${{ env.MODLOADER_VERSION }}
          path: final-output/*.html
          if-no-files-found: warn

  build_android:
    needs: [check_update, inject_modloader]
    if: needs.check_update.outputs.has_update == 'true' && needs.check_update.outputs.android_upload_id != ''
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
      ANDROID_UPLOAD_ID: ${{ needs.check_update.outputs.android_upload_id }}
      ANDROID_BUILD_ID: ${{ needs.check_update.outputs.android_build_id }}
      GAME_TYPE: ${{ needs.check_update.outputs.game_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests
          # å®‰è£…apktoolå’ŒAndroid SDKå·¥å…·
          sudo apt-get update
          sudo apt-get install -y apktool zipalign apksigner

      - name: Download ModLoader HTML artifact
        uses: actions/download-artifact@v4
        with:
          pattern: CourseOfTemptation-ModLoader-*
          path: modloader-html
          merge-multiple: true

      - name: Get ModLoader version from artifact
        id: get_ml_version
        shell: bash
        run: |
          # ä»ä¸‹è½½çš„artifactæ–‡ä»¶åä¸­æå–ModLoaderç‰ˆæœ¬
          HTML_FILE=$(ls modloader-html/*.html | grep -v polyfill | head -1)
          if [ -n "$HTML_FILE" ]; then
            BASENAME=$(basename "$HTML_FILE" .html)
            # æ–‡ä»¶åæ ¼å¼: CourseOfTemptation-ModLoader-{GAME_VER}-{ML_VER}.html
            ML_VER=$(echo "$BASENAME" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' | tail -1)
            echo "MODLOADER_VERSION=$ML_VER" >> $GITHUB_ENV
            echo "Detected ModLoader version: $ML_VER"
          else
            echo "MODLOADER_VERSION=unknown" >> $GITHUB_ENV
          fi

      - name: Download official Android APK
        env:
          ITCH_API_KEY: ${{ secrets.ITCH_API_KEY }}
          EA_PASSWORD: ${{ github.event.inputs.ea_password }}
        run: |
          python << 'EOF'
          import os
          import requests
          
          upload_id = os.environ["ANDROID_UPLOAD_ID"]
          build_id = os.environ["ANDROID_BUILD_ID"]
          api_key = os.environ.get("ITCH_API_KEY", "")
          ea_password = os.environ.get("EA_PASSWORD", "")
          game_type = os.environ.get("GAME_TYPE", "stable")
          
          # æ„å»ºä¸‹è½½URL
          # itch.io APKä¸‹è½½æ ¼å¼
          download_url = f"https://api.itch.io/uploads/{upload_id}/download"
          
          headers = {"Authorization": api_key} if api_key else {}
          params = {}
          if game_type == "ea" and ea_password:
              params["password"] = ea_password
          
          print(f"ä¸‹è½½Android APK: {download_url}")
          
          response = requests.get(download_url, headers=headers, params=params, allow_redirects=True, stream=True)
          response.raise_for_status()
          
          os.makedirs("apk-download", exist_ok=True)
          apk_path = "apk-download/original.apk"
          
          with open(apk_path, "wb") as f:
              for chunk in response.iter_content(chunk_size=8192):
                  f.write(chunk)
          
          file_size = os.path.getsize(apk_path)
          print(f"APKå·²ä¸‹è½½: {apk_path} ({file_size / 1024 / 1024:.2f} MB)")
          EOF

      - name: Extract real APK from downloaded archive
        run: |
          echo "æ£€æŸ¥ä¸‹è½½çš„æ–‡ä»¶..."
          file apk-download/original.apk
          echo ""
          echo "å°è¯•åˆ—å‡ºå†…å®¹:"
          unzip -l apk-download/original.apk | head -20
          echo ""
          
          # itch.ioä¸‹è½½çš„æ˜¯ZIPå‹ç¼©åŒ…ï¼Œé‡Œé¢åŒ…å«çœŸæ­£çš„APK
          echo "è§£å‹å¤–å±‚å‹ç¼©åŒ…..."
          mkdir -p apk-temp
          unzip -o apk-download/original.apk -d apk-temp
          
          # æ‰¾åˆ°çœŸæ­£çš„APKæ–‡ä»¶
          REAL_APK=$(find apk-temp -name "*.apk" -type f | head -1)
          if [ -z "$REAL_APK" ]; then
            echo "âŒ æœªæ‰¾åˆ°APKæ–‡ä»¶"
            ls -la apk-temp/
            exit 1
          fi
          
          echo "æ‰¾åˆ°çœŸæ­£çš„APK: $REAL_APK"
          mv "$REAL_APK" apk-download/game.apk
          echo "REAL_APK_PATH=apk-download/game.apk" >> $GITHUB_ENV
          
          file apk-download/game.apk
          ls -la apk-download/

      - name: Extract APK contents
        run: |
          echo "è§£å‹APKå†…å®¹..."
          mkdir -p apk-extracted
          unzip -o apk-download/game.apk -d apk-extracted
          echo ""
          echo "APKå†…å®¹ç»“æ„:"
          find apk-extracted -type d | head -30
          echo ""
          echo "æŸ¥æ‰¾æ‰€æœ‰htmlæ–‡ä»¶:"
          find apk-extracted -name "*.html" -type f

      - name: Find HTML file location
        run: |
          echo "æŸ¥æ‰¾HTMLæ–‡ä»¶ä½ç½®..."
          
          # å¸¸è§çš„HTMLä½ç½®
          HTML_LOCATIONS=(
            "apk-extracted/assets/www/index.html"
            "apk-extracted/assets/index.html"
            "apk-extracted/assets/game/index.html"
          )
          
          TARGET_HTML=""
          for loc in "${HTML_LOCATIONS[@]}"; do
            if [ -f "$loc" ]; then
              TARGET_HTML="$loc"
              echo "æ‰¾åˆ°HTML: $TARGET_HTML"
              break
            fi
          done
          
          if [ -z "$TARGET_HTML" ]; then
            echo "å°è¯•æœç´¢index.html..."
            TARGET_HTML=$(find apk-extracted -name "index.html" -type f | head -1)
          fi
          
          if [ -z "$TARGET_HTML" ]; then
            echo "âš ï¸ æœªæ‰¾åˆ°index.htmlï¼Œå°è¯•æŸ¥æ‰¾å…¶ä»–htmlæ–‡ä»¶..."
            TARGET_HTML=$(find apk-extracted -name "*.html" -type f | head -1)
          fi
          
          if [ -z "$TARGET_HTML" ]; then
            echo "âŒ æœªæ‰¾åˆ°ä»»ä½•HTMLæ–‡ä»¶"
            echo "å®Œæ•´çš„APKç›®å½•ç»“æ„:"
            find apk-extracted -type f
            exit 1
          fi
          
          echo "TARGET_HTML=$TARGET_HTML" >> $GITHUB_ENV
          echo "HTMLæ–‡ä»¶ä½ç½®: $TARGET_HTML"
          
          # è·å–ç›¸å¯¹è·¯å¾„ (å»æ‰apk-extracted/å‰ç¼€)
          RELATIVE_PATH="${TARGET_HTML#apk-extracted/}"
          echo "RELATIVE_HTML_PATH=$RELATIVE_PATH" >> $GITHUB_ENV
          echo "ç›¸å¯¹è·¯å¾„: $RELATIVE_PATH"

      - name: Replace HTML with ModLoader version
        run: |
          # æ‰¾åˆ°ModLoader HTML (æ™®é€šç‰ˆå’Œpolyfillç‰ˆ)
          MOD_HTML=$(ls modloader-html/*.html | grep -v polyfill | head -1)
          POLYFILL_HTML=$(ls modloader-html/*.html | grep polyfill | head -1)
          
          echo "ModLoader HTML: $MOD_HTML"
          echo "Polyfill HTML: $POLYFILL_HTML"
          echo "ç›®æ ‡HTMLè·¯å¾„: $RELATIVE_HTML_PATH"
          
          # åˆ›å»ºä¸¤ä¸ªç‰ˆæœ¬çš„APKç›®å½•
          cp -r apk-extracted apk-mod
          cp -r apk-extracted apk-polyfill
          
          # æ›¿æ¢HTMLæ–‡ä»¶
          if [ -n "$MOD_HTML" ] && [ -n "$RELATIVE_HTML_PATH" ]; then
            cp "$MOD_HTML" "apk-mod/$RELATIVE_HTML_PATH"
            echo "å·²æ›¿æ¢æ™®é€šç‰ˆHTML"
            ls -la "apk-mod/$RELATIVE_HTML_PATH"
          fi
          
          if [ -n "$POLYFILL_HTML" ] && [ -n "$RELATIVE_HTML_PATH" ]; then
            cp "$POLYFILL_HTML" "apk-polyfill/$RELATIVE_HTML_PATH"
            echo "å·²æ›¿æ¢Polyfillç‰ˆHTML"
          fi

      - name: Rebuild APK (normal version)
        run: |
          echo "é‡æ–°æ‰“åŒ…APK (æ™®é€šç‰ˆ)..."
          mkdir -p apk-output
          cd apk-mod
          zip -r ../apk-output/unsigned-mod.apk . -x "*.DS_Store"
          cd ..
          echo "APKå·²é‡æ–°æ‰“åŒ…"
          ls -la apk-output/

      - name: Rebuild APK (polyfill version)
        run: |
          echo "é‡æ–°æ‰“åŒ…APK (Polyfillç‰ˆ)..."
          cd apk-polyfill
          zip -r ../apk-output/unsigned-polyfill.apk . -x "*.DS_Store"
          cd ..
          echo "APKå·²é‡æ–°æ‰“åŒ…"

      - name: Sign APK with debug key
        run: |
          mkdir -p apk-signed
          
          # ç”Ÿæˆdebugç­¾åå¯†é’¥
          keytool -genkey -v -keystore debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000 -dname "CN=Android Debug,O=Android,C=US"
          
          # zipalign
          zipalign -v 4 apk-output/unsigned-mod.apk apk-output/aligned-mod.apk
          zipalign -v 4 apk-output/unsigned-polyfill.apk apk-output/aligned-polyfill.apk
          
          # ä½¿ç”¨apksignerç­¾å
          apksigner sign --ks debug.keystore --ks-pass pass:android --key-pass pass:android --out "apk-signed/CoT-ModLoader-${VERSION}-${MODLOADER_VERSION}.apk" apk-output/aligned-mod.apk
          apksigner sign --ks debug.keystore --ks-pass pass:android --key-pass pass:android --out "apk-signed/CoT-ModLoader-${VERSION}-${MODLOADER_VERSION}-polyfill.apk" apk-output/aligned-polyfill.apk
          
          echo "APKå·²ç­¾å"
          ls -la apk-signed/

      - name: Upload Android APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: CoT-Android-ModLoader-${{ env.VERSION }}-${{ env.MODLOADER_VERSION }}
          path: apk-signed/*.apk
          if-no-files-found: error