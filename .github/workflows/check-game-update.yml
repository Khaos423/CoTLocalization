name: Check Game Update

on:
  workflow_dispatch:
    inputs:
      game_type:
        description: 'æ¸¸æˆç‰ˆæœ¬ç±»å‹'
        required: true
        default: 'stable'
        type: choice
        options:
          - ea
          - stable
      ea_password:
        description: 'EAç‰ˆå¯†ç ï¼ˆä»…EAç‰ˆéœ€è¦ï¼‰'
        required: false
        type: string
      force_update:
        description: 'å¼ºåˆ¶æ›´æ–°ï¼ˆå¿½ç•¥ç‰ˆæœ¬ç¼“å­˜ï¼‰'
        required: false
        default: false
        type: boolean
  schedule:
    - cron: '0 */6 * * *'  # æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼ˆä»…æ£€æŸ¥ç¨³å®šç‰ˆï¼‰

jobs:
  check_update:
    runs-on: ubuntu-latest
    outputs:
      has_update: ${{ steps.check.outputs.has_update }}
      version: ${{ steps.check.outputs.version }}
      upload_id: ${{ steps.check.outputs.upload_id }}
      build_id: ${{ steps.check.outputs.build_id }}
      game_type: ${{ steps.check.outputs.game_type }}
      android_upload_id: ${{ steps.check.outputs.android_upload_id }}
      android_build_id: ${{ steps.check.outputs.android_build_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests

      - name: Restore version cache
        id: cache
        uses: actions/cache@v4
        with:
          path: .version_cache
          key: game-version-cache-${{ github.event.inputs.game_type || 'stable' }}
          restore-keys: |
            game-version-cache-

      - name: Check for updates
        id: check
        env:
          GAME_TYPE: ${{ github.event.inputs.game_type || 'stable' }}
          FORCE_UPDATE: ${{ github.event.inputs.force_update || 'false' }}
          ITCH_API_KEY: ${{ secrets.ITCH_API_KEY }}
          EA_PASSWORD: ${{ github.event.inputs.ea_password }}
        run: |
          python << 'EOF'
          import os
          import json
          import requests

          # é…ç½®
          STABLE_GAME_ID = "2151565"
          EA_GAME_ID = "2499529"
          UPLOADS_URL = "https://api.itch.io/games/{game_id}/uploads"
          API_KEY = os.environ.get("ITCH_API_KEY", "")
          EA_PASSWORD = os.environ.get("EA_PASSWORD", "")

          game_type = os.environ.get("GAME_TYPE", "stable")
          force_update = os.environ.get("FORCE_UPDATE", "false").lower() == "true"
          game_id = EA_GAME_ID if game_type == "ea" else STABLE_GAME_ID

          print(f"æ£€æŸ¥æ¸¸æˆæ›´æ–°: {game_type} (game_id: {game_id})")
          if force_update:
              print("âš ï¸ å¼ºåˆ¶æ›´æ–°æ¨¡å¼å·²å¯ç”¨")

          if not API_KEY:
              print("âš ï¸ è­¦å‘Š: ITCH_API_KEYæœªè®¾ç½®")
          
          if game_type == "ea" and not EA_PASSWORD:
              print("âŒ é”™è¯¯: EAç‰ˆéœ€è¦æä¾›å¯†ç ")
              exit(1)

          # è·å–ä¸Šä¼ åˆ—è¡¨ - ä½¿ç”¨Headerè®¤è¯
          url = UPLOADS_URL.format(game_id=game_id)
          headers = {"Authorization": API_KEY} if API_KEY else {}
          params = {"password": EA_PASSWORD} if game_type == "ea" and EA_PASSWORD else {}
          
          response = requests.get(url, headers=headers, params=params)
          response.raise_for_status()
          data = response.json()

          # æŸ¥æ‰¾HTML channel
          html_upload = None
          android_upload = None
          for upload in data.get("uploads", []):
              channel = upload.get("channel_name", "")
              if channel == "html":
                  html_upload = upload
              elif channel == "android":
                  android_upload = upload

          if not html_upload:
              print("æœªæ‰¾åˆ°HTML channel")
              exit(1)

          upload_id = html_upload.get("id")
          build_info = html_upload.get("build", {})
          build_id = build_info.get("id")
          version = build_info.get("user_version", str(build_info.get("version", "unknown")))

          print(f"HTML Upload ID: {upload_id}")
          print(f"HTML Build ID: {build_id}")
          print(f"Version: {version}")

          # Android APKä¿¡æ¯
          android_upload_id = ""
          android_build_id = ""
          if android_upload:
              android_upload_id = str(android_upload.get("id", ""))
              android_build_info = android_upload.get("build", {})
              android_build_id = str(android_build_info.get("id", ""))
              print(f"Android Upload ID: {android_upload_id}")
              print(f"Android Build ID: {android_build_id}")
          else:
              print("âš ï¸ æœªæ‰¾åˆ°Android channel")

          # ç‰ˆæœ¬ç¼“å­˜æ–‡ä»¶
          os.makedirs(".version_cache", exist_ok=True)
          version_file = f".version_cache/last_version_{game_type}.json"
          
          # è¯»å–ä¸Šæ¬¡ç¼“å­˜çš„ç‰ˆæœ¬
          last_version = None
          last_build_id = None
          if os.path.exists(version_file):
              try:
                  with open(version_file, "r") as f:
                      cached = json.load(f)
                      last_version = cached.get("version")
                      last_build_id = cached.get("build_id")
                  print(f"ä¸Šæ¬¡ç¼“å­˜ç‰ˆæœ¬: {last_version} (build_id: {last_build_id})")
              except Exception as e:
                  print(f"è¯»å–ç¼“å­˜å¤±è´¥: {e}")

          # æ£€æŸ¥æ˜¯å¦æœ‰æ–°ç‰ˆæœ¬
          has_update = "false"
          if force_update:
              has_update = "true"
              print("âœ… å¼ºåˆ¶æ›´æ–°")
          elif last_build_id is None:
              has_update = "true"
              print("âœ… é¦–æ¬¡è¿è¡Œï¼Œéœ€è¦æ›´æ–°")
          elif str(build_id) != str(last_build_id):
              has_update = "true"
              print(f"âœ… æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬: {last_version} -> {version}")
          else:
              print(f"â„¹ï¸ ç‰ˆæœ¬æœªå˜åŒ–: {version}")

          # ä¿å­˜å½“å‰ç‰ˆæœ¬åˆ°ç¼“å­˜
          with open(version_file, "w") as f:
              json.dump({
                  "version": version,
                  "build_id": build_id,
                  "upload_id": upload_id
              }, f)
          print(f"ç‰ˆæœ¬ä¿¡æ¯å·²ç¼“å­˜åˆ°: {version_file}")
          
          # è¾“å‡ºåˆ°GitHub Actions
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"has_update={has_update}\n")
              f.write(f"version={version}\n")
              f.write(f"upload_id={upload_id}\n")
              f.write(f"build_id={build_id}\n")
              f.write(f"game_type={game_type}\n")
              f.write(f"android_upload_id={android_upload_id}\n")
              f.write(f"android_build_id={android_build_id}\n")
          
          print(f"\n{'ğŸš€ å°†æ‰§è¡Œæ›´æ–°' if has_update == 'true' else 'â­ï¸ è·³è¿‡æ›´æ–°'}")
          EOF

      - name: Save version cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .version_cache
          key: game-version-cache-${{ github.event.inputs.game_type || 'ea' }}-${{ github.run_id }}

  download_and_export:
    needs: check_update
    if: needs.check_update.outputs.has_update == 'true'
    runs-on: windows-latest
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
      UPLOAD_ID: ${{ needs.check_update.outputs.upload_id }}
      BUILD_ID: ${{ needs.check_update.outputs.build_id }}
      PYTHONIOENCODING: utf-8
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests selenium webdriver-manager

      - name: Setup Chrome
        uses: browser-actions/setup-chrome@latest

      - name: Download HTML file
        shell: bash
        run: |
          python << 'EOF'
          import os
          import requests

          upload_id = os.environ["UPLOAD_ID"]
          build_id = os.environ["BUILD_ID"]
          version = os.environ["VERSION"]

          html_url = f"https://html-classic.itch.zone/html/{upload_id}-{build_id}/index.html"
          print(f"ä¸‹è½½HTML: {html_url}")

          response = requests.get(html_url, stream=True)
          response.raise_for_status()

          os.makedirs("temp_update_files", exist_ok=True)
          html_path = f"temp_update_files/index{version}.html"
          
          with open(html_path, "wb") as f:
              for chunk in response.iter_content(chunk_size=8192):
                  f.write(chunk)
          
          print(f"HTMLå·²ä¿å­˜åˆ°: {html_path}")
          
          # ä¿å­˜è·¯å¾„ä¾›åç»­æ­¥éª¤ä½¿ç”¨
          with open(os.environ["GITHUB_ENV"], "a") as f:
              f.write(f"HTML_PATH={os.path.abspath(html_path)}\n")
          EOF

      - name: Export story data
        shell: bash
        run: |
          python << 'EOF'
          import os
          import time
          from selenium import webdriver
          from selenium.webdriver.chrome.service import Service as ChromeService
          from webdriver_manager.chrome import ChromeDriverManager
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC

          html_path = os.environ["HTML_PATH"]
          version = os.environ["VERSION"]
          
          # æ£€æŸ¥story-export.jsæ˜¯å¦å­˜åœ¨
          js_path = "story-export.js"
          if not os.path.exists(js_path):
              print(f"è­¦å‘Š: {js_path} ä¸å­˜åœ¨ï¼Œè·³è¿‡æµè§ˆå™¨è‡ªåŠ¨åŒ–æ­¥éª¤")
              print("è¯·ç¡®ä¿story-export.jsæ–‡ä»¶å·²æ·»åŠ åˆ°ä»“åº“ä¸­")
              exit(0)

          # é…ç½®Chrome headless
          options = webdriver.ChromeOptions()
          options.add_argument("--headless=new")
          options.add_argument("--no-sandbox")
          options.add_argument("--disable-dev-shm-usage")
          options.add_argument("--disable-gpu")
          
          download_dir = os.path.abspath(".")
          prefs = {
              "download.default_directory": download_dir,
              "download.prompt_for_download": False,
              "download.directory_upgrade": True,
              "safebrowsing.enabled": True
          }
          options.add_experimental_option("prefs", prefs)

          driver = None
          try:
              service = ChromeService(ChromeDriverManager().install())
              driver = webdriver.Chrome(service=service, options=options)
              
              # headlessæ¨¡å¼ä¸‹è®¾ç½®ä¸‹è½½è¡Œä¸º
              driver.execute_cdp_cmd("Page.setDownloadBehavior", {
                  "behavior": "allow",
                  "downloadPath": download_dir
              })
              
              driver.get("file://" + html_path)
              
              WebDriverWait(driver, 10).until(
                  EC.presence_of_element_located((By.TAG_NAME, "body"))
              )
              print("é¡µé¢å·²åŠ è½½")

              with open(js_path, "r", encoding="utf-8") as f:
                  js_code = f.read()
              
              print("æ‰§è¡Œå¯¼å‡ºè„šæœ¬...")
              driver.execute_script(js_code)
              
              # ç­‰å¾…ä¸‹è½½å®Œæˆ
              zip_path = os.path.join(download_dir, "story_export.zip")
              timeout = 60
              start_time = time.time()
              while not os.path.exists(zip_path):
                  time.sleep(1)
                  if time.time() - start_time > timeout:
                      print("ä¸‹è½½è¶…æ—¶")
                      exit(1)
              
              print(f"å¯¼å‡ºå®Œæˆ: {zip_path}")

          except Exception as e:
              print(f"é”™è¯¯: {e}")
              exit(1)
          finally:
              if driver:
                  driver.quit()
          EOF

      - name: Upload HTML artifact
        uses: actions/upload-artifact@v4
        with:
          name: game-html-${{ env.VERSION }}
          path: temp_update_files/*.html
          if-no-files-found: warn

      - name: Upload story export artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: story-export-${{ env.VERSION }}
          path: story_export.zip
          if-no-files-found: warn

  inject_modloader:
    needs: [check_update, download_and_export]
    if: needs.check_update.outputs.has_update == 'true'
    runs-on: windows-latest
    permissions:
      contents: write
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
      PYTHONIOENCODING: utf-8
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download HTML artifact
        uses: actions/download-artifact@v4
        with:
          name: game-html-${{ env.VERSION }}
          path: game-html

      - name: Use Node.js 18.x
        uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Download ModLoader Package from workflow artifact
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          repo: Lyoko-Jeremie/sugarcube-2-ModLoader
          workflow: Build-ModLoader-Package.yml
          workflow_conclusion: success
          name: ModLoader Package
          path: modloader-download
          search_artifacts: true

      - name: Setup ModLoader Package
        shell: pwsh
        run: |
          Write-Host "=== Downloaded files in modloader-download (top level) ==="
          Get-ChildItem -Path "modloader-download" | ForEach-Object { Write-Host $_.Name }
          
          # æ£€æŸ¥ dist-insertTools æ˜¯å¦ç›´æ¥åœ¨ modloader-download ä¸­
          if (Test-Path "modloader-download/dist-insertTools") {
            Write-Host ""
            Write-Host "dist-insertTools found directly in modloader-download"
            Write-Host "Renaming modloader-download to ml-package..."
            Rename-Item -Path "modloader-download" -NewName "ml-package"
          } else {
            Write-Host "ERROR: dist-insertTools not found in modloader-download"
            Write-Host "Full contents:"
            Get-ChildItem -Path "modloader-download" -Recurse | Select-Object -First 50 | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }
          
          Write-Host ""
          Write-Host "=== ml-package contents ==="
          Get-ChildItem -Path "ml-package" | ForEach-Object { Write-Host $_.Name }
          
          # éªŒè¯å…³é”®ç›®å½•
          if (Test-Path "ml-package/dist-insertTools") {
            Write-Host "âœ“ dist-insertTools OK"
          } else {
            Write-Host "âœ— dist-insertTools MISSING"
            exit 1
          }
          
          if (Test-Path "ml-package/dist-BeforeSC2") {
            Write-Host "âœ“ dist-BeforeSC2 OK"
          } else {
            Write-Host "âœ— dist-BeforeSC2 MISSING"
            exit 1
          }

      - name: Checkout SugarCube-2
        uses: actions/checkout@v4
        with:
          repository: Lyoko-Jeremie/sugarcube-2_Vrelnir
          path: SC2
          ref: TS2

      - name: Build SugarCube-2
        working-directory: ${{ github.workspace }}/SC2
        run: |
          npm install
          node build.js -d -u -b 2

      - name: Copy SC2 format.js
        shell: bash
        run: |
          cp SC2/build/twine2/sugarcube-2/format.js ml-package/format.js
          echo "Copied format.js to ml-package/"
          ls -la ml-package/format.js

      - name: Get ModLoader version
        id: modloader_version
        shell: bash
        run: |
          # ä» dist-BeforeSC2/Utils.js ä¸­æå–ç‰ˆæœ¬å·
          UTILS_FILE="ml-package/dist-BeforeSC2/Utils.js"
          
          echo "Looking for: $UTILS_FILE"
          if [ -f "$UTILS_FILE" ]; then
            echo "Found Utils.js"
            # æå–ç‰ˆæœ¬å· - ç®€åŒ–æ­£åˆ™
            ML_VERSION=$(grep -oE "[0-9]+\.[0-9]+\.[0-9]+" "$UTILS_FILE" | head -1)
            echo "Extracted version: $ML_VERSION"
          else
            echo "Utils.js not found, searching..."
            find ml-package -name "Utils.js" -type f
          fi
          
          if [ -z "$ML_VERSION" ]; then
            ML_VERSION="unknown"
          fi
          
          echo "ModLoader Version: $ML_VERSION"
          echo "MODLOADER_VERSION=$ML_VERSION" >> $GITHUB_ENV

      - name: Copy modList.json
        shell: bash
        run: |
          cp modloader/modList.json ml-package/modList.json
          echo "Copied modList.json to ml-package/"

      - name: Find and set HTML filename
        shell: bash
        run: |
          HTML_FILE=$(ls game-html/*.html | head -1)
          HTML_BASENAME=$(basename "$HTML_FILE")
          echo "HTML_FILE=$HTML_FILE" >> $GITHUB_ENV
          echo "HTML_BASENAME=$HTML_BASENAME" >> $GITHUB_ENV
          echo "Found HTML file: $HTML_FILE"

      - name: SC2 Replace
        shell: pwsh
        working-directory: ${{ github.workspace }}/ml-package
        run: |
          $htmlPath = "${{ github.workspace }}/${{ env.HTML_FILE }}"
          $formatPath = Get-ChildItem -Path "." -Filter "format.js" -Recurse | Select-Object -First 1
          if ($formatPath) {
            Write-Host "Using format.js: $($formatPath.FullName)"
            node "dist-insertTools/sc2ReplaceTool.js" $htmlPath $formatPath.FullName
          } else {
            Write-Host "format.js not found, skipping SC2 replace"
            Copy-Item $htmlPath "$htmlPath.sc2replace.html"
          }

      - name: Inject ModLoader
        shell: pwsh
        working-directory: ${{ github.workspace }}/ml-package
        run: |
          $htmlPath = "${{ github.workspace }}/${{ env.HTML_FILE }}.sc2replace.html"
          node "dist-insertTools/insert2html.js" $htmlPath "modList.json" "dist-BeforeSC2/BeforeSC2.js" ""

      - name: Inject ModLoader (polyfill)
        shell: pwsh
        working-directory: ${{ github.workspace }}/ml-package
        run: |
          $htmlPath = "${{ github.workspace }}/${{ env.HTML_FILE }}.sc2replace.html"
          $polyfillPath = "dist-BeforeSC2/polyfill.js"
          if (Test-Path $polyfillPath) {
            node "dist-insertTools/insert2html-polyfill.js" $htmlPath "modList.json" "dist-BeforeSC2/BeforeSC2.js" $polyfillPath "ManualPolyfill.js"
          } else {
            Write-Host "polyfill.js not found, skipping polyfill injection"
          }

      - name: Apply CoT specific patches
        shell: bash
        run: |
          MOD_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod.html"
          POLYFILL_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod-polyfill.html"
          
          if [ -f "$MOD_HTML" ]; then
            python modloader/replace.py "$MOD_HTML"
          fi
          
          if [ -f "$POLYFILL_HTML" ]; then
            python modloader/replace.py "$POLYFILL_HTML"
          fi

      - name: Prepare final output
        shell: bash
        run: |
          mkdir -p final-output
          
          MOD_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod.html"
          POLYFILL_HTML="${{ env.HTML_FILE }}.sc2replace.html.mod-polyfill.html"
          GAME_VER="${VERSION}"
          ML_VER="${MODLOADER_VERSION}"
          
          if [ -f "$MOD_HTML" ]; then
            cp "$MOD_HTML" "final-output/CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}.html"
            echo "Created: CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}.html"
          fi
          
          if [ -f "$POLYFILL_HTML" ]; then
            cp "$POLYFILL_HTML" "final-output/CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}-polyfill.html"
            echo "Created: CourseOfTemptation-ModLoader-${GAME_VER}-${ML_VER}-polyfill.html"
          fi
          
          ls -la final-output/

      - name: Upload ModLoader injected HTML
        uses: actions/upload-artifact@v4
        with:
          name: CourseOfTemptation-ModLoader-${{ env.VERSION }}-${{ env.MODLOADER_VERSION }}
          path: final-output/*.html
          if-no-files-found: warn


  build_android:
    needs: [check_update, inject_modloader]
    if: needs.check_update.outputs.has_update == 'true' && needs.check_update.outputs.android_upload_id != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
      ANDROID_UPLOAD_ID: ${{ needs.check_update.outputs.android_upload_id }}
      ANDROID_BUILD_ID: ${{ needs.check_update.outputs.android_build_id }}
      GAME_TYPE: ${{ needs.check_update.outputs.game_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests
          # å®‰è£…apktoolå’ŒAndroid SDKå·¥å…·
          sudo apt-get update
          sudo apt-get install -y apktool zipalign apksigner

      - name: Download ModLoader HTML artifact
        uses: actions/download-artifact@v4
        with:
          pattern: CourseOfTemptation-ModLoader-*
          path: modloader-html
          merge-multiple: true

      - name: Get ModLoader version from artifact
        id: get_ml_version
        shell: bash
        run: |
          # ä»ä¸‹è½½çš„artifactæ–‡ä»¶åä¸­æå–ModLoaderç‰ˆæœ¬
          HTML_FILE=$(ls modloader-html/*.html | grep -v polyfill | head -1)
          if [ -n "$HTML_FILE" ]; then
            BASENAME=$(basename "$HTML_FILE" .html)
            # æ–‡ä»¶åæ ¼å¼: CourseOfTemptation-ModLoader-{GAME_VER}-{ML_VER}.html
            ML_VER=$(echo "$BASENAME" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | tail -1)
            echo "MODLOADER_VERSION=$ML_VER" >> $GITHUB_ENV
            echo "Detected ModLoader version: $ML_VER"
          else
            echo "MODLOADER_VERSION=unknown" >> $GITHUB_ENV
          fi

      - name: Download official Android APK
        env:
          ITCH_API_KEY: ${{ secrets.ITCH_API_KEY }}
          EA_PASSWORD: ${{ github.event.inputs.ea_password }}
        run: |
          python << 'EOF'
          import os
          import requests
          
          upload_id = os.environ["ANDROID_UPLOAD_ID"]
          build_id = os.environ["ANDROID_BUILD_ID"]
          api_key = os.environ.get("ITCH_API_KEY", "")
          ea_password = os.environ.get("EA_PASSWORD", "")
          game_type = os.environ.get("GAME_TYPE", "stable")
          
          # æ„å»ºä¸‹è½½URL
          # itch.io APKä¸‹è½½æ ¼å¼
          download_url = f"https://api.itch.io/uploads/{upload_id}/download"
          
          headers = {"Authorization": api_key} if api_key else {}
          params = {}
          if game_type == "ea" and ea_password:
              params["password"] = ea_password
          
          print(f"ä¸‹è½½Android APK: {download_url}")
          
          response = requests.get(download_url, headers=headers, params=params, allow_redirects=True, stream=True)
          response.raise_for_status()
          
          os.makedirs("apk-download", exist_ok=True)
          apk_path = "apk-download/original.apk"
          
          with open(apk_path, "wb") as f:
              for chunk in response.iter_content(chunk_size=8192):
                  f.write(chunk)
          
          file_size = os.path.getsize(apk_path)
          print(f"APKå·²ä¸‹è½½: {apk_path} ({file_size / 1024 / 1024:.2f} MB)")
          EOF

      - name: Extract real APK from downloaded archive
        run: |
          echo "æ£€æŸ¥ä¸‹è½½çš„æ–‡ä»¶..."
          file apk-download/original.apk
          echo ""
          echo "å°è¯•åˆ—å‡ºå†…å®¹:"
          unzip -l apk-download/original.apk | head -20
          echo ""
          
          # itch.ioä¸‹è½½çš„æ˜¯ZIPå‹ç¼©åŒ…ï¼Œé‡Œé¢åŒ…å«çœŸæ­£çš„APK
          echo "è§£å‹å¤–å±‚å‹ç¼©åŒ…..."
          mkdir -p apk-temp
          unzip -o apk-download/original.apk -d apk-temp
          
          # æ‰¾åˆ°çœŸæ­£çš„APKæ–‡ä»¶
          REAL_APK=$(find apk-temp -name "*.apk" -type f | head -1)
          if [ -z "$REAL_APK" ]; then
            echo "âŒ æœªæ‰¾åˆ°APKæ–‡ä»¶"
            ls -la apk-temp/
            exit 1
          fi
          
          echo "æ‰¾åˆ°çœŸæ­£çš„APK: $REAL_APK"
          mv "$REAL_APK" apk-download/game.apk
          echo "REAL_APK_PATH=apk-download/game.apk" >> $GITHUB_ENV
          
          file apk-download/game.apk
          ls -la apk-download/

      - name: Find HTML path in APK
        run: |
          echo "æŸ¥æ‰¾APKå†…HTMLæ–‡ä»¶ä½ç½®..."
          
          # åˆ—å‡ºAPKå†…å®¹ï¼ŒæŸ¥æ‰¾HTMLæ–‡ä»¶
          unzip -l apk-download/game.apk | grep -E "\.html$" | head -10
          
          # è·å–HTMLæ–‡ä»¶è·¯å¾„
          HTML_PATH_IN_APK=$(unzip -l apk-download/game.apk | grep -oE "[^ ]+index\.html" | head -1)
          
          if [ -z "$HTML_PATH_IN_APK" ]; then
            echo "å°è¯•æŸ¥æ‰¾ä»»æ„htmlæ–‡ä»¶..."
            HTML_PATH_IN_APK=$(unzip -l apk-download/game.apk | grep -oE "[^ ]+\.html" | head -1)
          fi
          
          if [ -z "$HTML_PATH_IN_APK" ]; then
            echo "âŒ æœªæ‰¾åˆ°HTMLæ–‡ä»¶"
            echo "APKå†…å®¹:"
            unzip -l apk-download/game.apk
            exit 1
          fi
          
          echo "HTML_PATH_IN_APK=$HTML_PATH_IN_APK" >> $GITHUB_ENV
          echo "APKå†…HTMLè·¯å¾„: $HTML_PATH_IN_APK"

      - name: Create modified APKs
        run: |
          # æ‰¾åˆ°ModLoader HTML (æ™®é€šç‰ˆå’Œpolyfillç‰ˆ)
          MOD_HTML=$(ls modloader-html/*.html | grep -v polyfill | head -1)
          POLYFILL_HTML=$(ls modloader-html/*.html | grep polyfill | head -1)
          
          echo "ModLoader HTML: $MOD_HTML"
          echo "Polyfill HTML: $POLYFILL_HTML"
          echo "APKå†…HTMLè·¯å¾„: $HTML_PATH_IN_APK"
          
          mkdir -p apk-output
          
          # åˆ›å»ºæ™®é€šç‰ˆAPK
          if [ -n "$MOD_HTML" ]; then
            echo "åˆ›å»ºæ™®é€šç‰ˆAPK..."
            cp apk-download/game.apk apk-output/mod.apk
            
            # å‡†å¤‡æ›¿æ¢çš„HTMLæ–‡ä»¶ï¼ˆéœ€è¦æ”¾åœ¨æ­£ç¡®çš„ç›®å½•ç»“æ„ä¸­ï¼‰
            HTML_DIR=$(dirname "$HTML_PATH_IN_APK")
            mkdir -p "temp-html/$HTML_DIR"
            cp "$MOD_HTML" "temp-html/$HTML_PATH_IN_APK"
            
            # ä½¿ç”¨zipæ›´æ–°APKå†…çš„æ–‡ä»¶
            cd temp-html
            zip -u ../apk-output/mod.apk "$HTML_PATH_IN_APK"
            cd ..
            rm -rf temp-html
            
            # åˆ é™¤æ—§ç­¾å
            zip -d apk-output/mod.apk "META-INF/*" || true
            
            echo "æ™®é€šç‰ˆAPKå·²åˆ›å»º"
          fi
          
          # åˆ›å»ºpolyfillç‰ˆAPK
          if [ -n "$POLYFILL_HTML" ]; then
            echo "åˆ›å»ºPolyfillç‰ˆAPK..."
            cp apk-download/game.apk apk-output/polyfill.apk
            
            # å‡†å¤‡æ›¿æ¢çš„HTMLæ–‡ä»¶
            HTML_DIR=$(dirname "$HTML_PATH_IN_APK")
            mkdir -p "temp-html/$HTML_DIR"
            cp "$POLYFILL_HTML" "temp-html/$HTML_PATH_IN_APK"
            
            # ä½¿ç”¨zipæ›´æ–°APKå†…çš„æ–‡ä»¶
            cd temp-html
            zip -u ../apk-output/polyfill.apk "$HTML_PATH_IN_APK"
            cd ..
            rm -rf temp-html
            
            # åˆ é™¤æ—§ç­¾å
            zip -d apk-output/polyfill.apk "META-INF/*" || true
            
            echo "Polyfillç‰ˆAPKå·²åˆ›å»º"
          fi
          
          ls -la apk-output/

      - name: Setup signing keystore
        run: |
          # ä» GitHub Secret è§£ç  keystore
          echo "${{ secrets.APK_KEYSTORE_BASE64 }}" | base64 -d > signing.keystore
          echo "Keystore file created"

      - name: Sign APKs
        run: |
          mkdir -p apk-signed
          
          KEYSTORE_FILE="signing.keystore"
          KEYSTORE_PASS="${{ secrets.APK_KEYSTORE_PASSWORD }}"
          KEY_ALIAS="${{ secrets.APK_KEY_ALIAS }}"
          KEY_PASS="${{ secrets.APK_KEY_PASSWORD }}"
          
          echo "âœ… ä½¿ç”¨é…ç½®çš„å›ºå®šç­¾åå¯†é’¥"
          
          # å¤„ç†æ™®é€šç‰ˆ
          if [ -f "apk-output/mod.apk" ]; then
            echo "ç­¾åæ™®é€šç‰ˆAPK..."
            # zipalign
            zipalign -v 4 apk-output/mod.apk apk-output/aligned-mod.apk
            # ç­¾å
            apksigner sign --ks "$KEYSTORE_FILE" --ks-pass "pass:$KEYSTORE_PASS" --ks-key-alias "$KEY_ALIAS" --key-pass "pass:$KEY_PASS" --out "apk-signed/CoT-ModLoader-${VERSION}-${MODLOADER_VERSION}.apk" apk-output/aligned-mod.apk
          fi
          
          # å¤„ç†polyfillç‰ˆ
          if [ -f "apk-output/polyfill.apk" ]; then
            echo "ç­¾åPolyfillç‰ˆAPK..."
            # zipalign
            zipalign -v 4 apk-output/polyfill.apk apk-output/aligned-polyfill.apk
            # ç­¾å
            apksigner sign --ks "$KEYSTORE_FILE" --ks-pass "pass:$KEYSTORE_PASS" --ks-key-alias "$KEY_ALIAS" --key-pass "pass:$KEY_PASS" --out "apk-signed/CoT-ModLoader-${VERSION}-${MODLOADER_VERSION}-polyfill.apk" apk-output/aligned-polyfill.apk
          fi
          
          echo "APKç­¾åå®Œæˆ"
          ls -la apk-signed/
          
          # éªŒè¯ç­¾å
          echo ""
          echo "éªŒè¯APKç­¾å..."
          for apk in apk-signed/*.apk; do
            echo "éªŒè¯: $apk"
            apksigner verify --verbose "$apk" || true
          done

      - name: Upload Android APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: CoT-Android-ModLoader-${{ env.VERSION }}-${{ env.MODLOADER_VERSION }}
          path: apk-signed/*.apk
          if-no-files-found: error


  build_image_pack:
    needs: [check_update]
    if: needs.check_update.outputs.has_update == 'true' && needs.check_update.outputs.android_upload_id != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
      ANDROID_UPLOAD_ID: ${{ needs.check_update.outputs.android_upload_id }}
      ANDROID_BUILD_ID: ${{ needs.check_update.outputs.android_build_id }}
      GAME_TYPE: ${{ needs.check_update.outputs.game_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js 18.x
        uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: Enable Corepack
        run: corepack enable

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install requests

      - name: Download official Android APK
        env:
          ITCH_API_KEY: ${{ secrets.ITCH_API_KEY }}
          EA_PASSWORD: ${{ github.event.inputs.ea_password }}
        run: |
          python << 'EOF'
          import os
          import requests
          
          upload_id = os.environ["ANDROID_UPLOAD_ID"]
          build_id = os.environ["ANDROID_BUILD_ID"]
          api_key = os.environ.get("ITCH_API_KEY", "")
          ea_password = os.environ.get("EA_PASSWORD", "")
          game_type = os.environ.get("GAME_TYPE", "stable")
          
          download_url = f"https://api.itch.io/uploads/{upload_id}/download"
          
          headers = {"Authorization": api_key} if api_key else {}
          params = {}
          if game_type == "ea" and ea_password:
              params["password"] = ea_password
          
          print(f"ä¸‹è½½Android APK: {download_url}")
          
          response = requests.get(download_url, headers=headers, params=params, allow_redirects=True, stream=True)
          response.raise_for_status()
          
          os.makedirs("apk-download", exist_ok=True)
          apk_path = "apk-download/original.apk"
          
          with open(apk_path, "wb") as f:
              for chunk in response.iter_content(chunk_size=8192):
                  f.write(chunk)
          
          file_size = os.path.getsize(apk_path)
          print(f"APKå·²ä¸‹è½½: {apk_path} ({file_size / 1024 / 1024:.2f} MB)")
          EOF

      - name: Extract APK and get res directory
        run: |
          echo "æ£€æŸ¥ä¸‹è½½çš„æ–‡ä»¶..."
          file apk-download/original.apk
          
          # itch.ioä¸‹è½½çš„æ˜¯ZIPå‹ç¼©åŒ…ï¼Œé‡Œé¢åŒ…å«çœŸæ­£çš„APK
          echo "è§£å‹å¤–å±‚å‹ç¼©åŒ…..."
          mkdir -p apk-temp
          unzip -o apk-download/original.apk -d apk-temp
          
          # æ‰¾åˆ°çœŸæ­£çš„APKæ–‡ä»¶
          REAL_APK=$(find apk-temp -name "*.apk" -type f | head -1)
          if [ -z "$REAL_APK" ]; then
            echo "âŒ æœªæ‰¾åˆ°APKæ–‡ä»¶"
            ls -la apk-temp/
            exit 1
          fi
          
          echo "æ‰¾åˆ°çœŸæ­£çš„APK: $REAL_APK"
          
          # è§£å‹APKè·å–resç›®å½•
          echo "è§£å‹APK..."
          mkdir -p apk-contents
          unzip -o "$REAL_APK" -d apk-contents
          
          # æŸ¥æ‰¾resç›®å½•ï¼ˆCoTæ¸¸æˆçš„èµ„æºè·¯å¾„ï¼‰
          echo "æŸ¥æ‰¾resç›®å½•..."
          RES_DIR=$(find apk-contents -type d -name "res" -path "*assets*" | head -1)
          
          if [ -z "$RES_DIR" ]; then
            echo "å°è¯•å…¶ä»–è·¯å¾„..."
            RES_DIR=$(find apk-contents -type d -path "*/www/res" | head -1)
          fi
          
          if [ -z "$RES_DIR" ]; then
            echo "âŒ æœªæ‰¾åˆ°resç›®å½•"
            echo "APKå†…å®¹ç»“æ„:"
            find apk-contents -type d | head -50
            exit 1
          fi
          
          echo "æ‰¾åˆ°resç›®å½•: $RES_DIR"
          
          # å¤åˆ¶resç›®å½•
          mkdir -p game-res
          cp -r "$RES_DIR" game-res/
          
          echo "resç›®å½•å†…å®¹:"
          ls -la game-res/res/ | head -20
          echo ""
          echo "æ€»å›¾ç‰‡æ–‡ä»¶æ•°: $(find game-res -type f \( -name "*.png" -o -name "*.jpg" -o -name "*.gif" -o -name "*.webp" \) | wc -l)"

      - name: Download ModLoader Package
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          repo: Lyoko-Jeremie/sugarcube-2-ModLoader
          workflow: Build-ModLoader-Package.yml
          workflow_conclusion: success
          name: ModLoader Package
          path: ModLoader
          search_artifacts: true

      - name: Verify ModLoader structure
        run: |
          echo "=== ModLoader contents ==="
          ls -la ModLoader/ | head -20
          
          if [ ! -d "ModLoader/dist-insertTools" ]; then
            echo "ERROR: dist-insertTools not found"
            exit 1
          fi
          echo "âœ“ ModLoader structure OK"

      - name: Checkout GameOriginalImagePackMod
        uses: actions/checkout@v4
        with:
          repository: Lyoko-Jeremie/GameOriginalImagePackMod
          path: ModLoader/mod/GameOriginalImagePack
          ref: master

      - name: Build GameOriginalImagePack
        working-directory: ${{ github.workspace }}/ModLoader/mod/GameOriginalImagePack
        run: |
          yarn install
          yarn run build:ts
          yarn run build:webpack
          yarn run build:tools

      - name: Copy res to GameOriginalImagePack
        run: |
          echo "Copying res directory to GameOriginalImagePack..."
          # å¤åˆ¶resç›®å½•ï¼ˆCoTçš„è·¯å¾„æ˜¯res/img/xxx.pngï¼‰
          cp -r game-res/res ModLoader/mod/GameOriginalImagePack/
          echo "resç›®å½•å·²å¤åˆ¶"
          ls -la ModLoader/mod/GameOriginalImagePack/
          echo ""
          echo "res/imgå†…å®¹:"
          ls -la ModLoader/mod/GameOriginalImagePack/res/img/ 2>/dev/null | head -10

      - name: Generate boot.json using bootJsonFillTool
        working-directory: ${{ github.workspace }}/ModLoader/mod/GameOriginalImagePack
        run: |
          echo "Game Version: $VERSION"
          # ä½¿ç”¨ GameOriginalImagePackMod è‡ªå¸¦çš„å·¥å…·ç”Ÿæˆ boot.json
          # bootJsonFillTool.js <template> <imgDir> <version>
          node dist-tools/bootJsonFillTool.js "bootTemplate.json" "res" "$VERSION"
          
          echo ""
          echo "boot.json content (å‰50è¡Œ):"
          head -50 boot.json
          echo "..."
          echo "boot.json content (å10è¡Œ):"
          tail -10 boot.json

      - name: Pack mod zip
        working-directory: ${{ github.workspace }}/ModLoader/mod/GameOriginalImagePack
        run: |
          echo "Packing mod..."
          node "${{ github.workspace }}/ModLoader/dist-insertTools/packModZip.js" "boot.json"
          
          echo "Mod package created:"
          ls -la *.mod.zip 2>/dev/null || ls -la *.zip 2>/dev/null || echo "No zip files found"

      - name: Prepare output
        run: |
          mkdir -p image-pack-output
          
          # æŸ¥æ‰¾ç”Ÿæˆçš„mod.zipæ–‡ä»¶
          MOD_FILE=$(find ModLoader/mod/GameOriginalImagePack -name "*.mod.zip" -type f | head -1)
          if [ -z "$MOD_FILE" ]; then
            MOD_FILE=$(find ModLoader/mod/GameOriginalImagePack -name "*.zip" -type f | head -1)
          fi
          
          if [ -n "$MOD_FILE" ]; then
            cp "$MOD_FILE" "image-pack-output/GameOriginalImagePack-${VERSION}.mod.zip"
            echo "Created: GameOriginalImagePack-${VERSION}.mod.zip"
          else
            echo "âŒ No mod zip file found"
            find ModLoader/mod/GameOriginalImagePack -type f -name "*.zip"
            exit 1
          fi
          
          ls -la image-pack-output/

      - name: Upload GameOriginalImagePack artifact
        uses: actions/upload-artifact@v4
        with:
          name: GameOriginalImagePack-${{ env.VERSION }}
          path: image-pack-output/*.mod.zip
          if-no-files-found: error

  # ç»Ÿä¸€å‘å¸ƒæ‰€æœ‰æ„å»ºäº§ç‰©
  release_all:
    needs: [check_update, inject_modloader, build_android, build_image_pack]
    if: always() && needs.check_update.outputs.has_update == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      VERSION: ${{ needs.check_update.outputs.version }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts
          merge-multiple: false

      - name: Download ModI18N from build-i18n workflow
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          repo: ${{ github.repository }}
          workflow: build-i18n.yml
          workflow_conclusion: success
          name_is_regexp: true
          name: ModI18N-.*
          path: i18n-artifact
          search_artifacts: true
        continue-on-error: true

      - name: Prepare release files
        run: |
          mkdir -p release-files
          mkdir -p html-temp
          
          echo "=== Downloaded artifacts ==="
          find all-artifacts -type f | head -50
          
          # å¤åˆ¶æ‰€æœ‰ HTML æ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•
          find all-artifacts -name "*.html" -exec cp {} html-temp/ \;
          
          # ä»æ–‡ä»¶åæå– ModLoader ç‰ˆæœ¬
          HTML_FILE=$(ls html-temp/*.html 2>/dev/null | grep -v polyfill | head -1)
          if [ -n "$HTML_FILE" ]; then
            BASENAME=$(basename "$HTML_FILE" .html)
            ML_VER=$(echo "$BASENAME" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | tail -1)
            echo "MODLOADER_VERSION=$ML_VER" >> $GITHUB_ENV
            echo "Detected ModLoader version: $ML_VER"
          else
            ML_VER="unknown"
            echo "MODLOADER_VERSION=unknown" >> $GITHUB_ENV
          fi
          
          # å°† HTML æ–‡ä»¶æ‰“åŒ…ä¸º zip
          # VERSION æ ¼å¼: 0.7.3g, ML_VER æ ¼å¼: 2.33.2
          if [ -n "$(ls html-temp/*.html 2>/dev/null)" ]; then
            ZIP_NAME="CoT-ModLoader-v${VERSION}-v${ML_VER}.zip"
            cd html-temp
            zip "../release-files/${ZIP_NAME}" *.html
            cd ..
            echo "Created HTML zip: ${ZIP_NAME}"
          fi
          
          # å¤åˆ¶æ‰€æœ‰ APK æ–‡ä»¶
          find all-artifacts -name "*.apk" -exec cp {} release-files/ \;
          
          # å¤åˆ¶æ‰€æœ‰ mod.zip æ–‡ä»¶
          find all-artifacts -name "*.mod.zip" -exec cp {} release-files/ \;
          
          # å¤åˆ¶ ModI18N æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if [ -d "i18n-artifact" ]; then
            find i18n-artifact -name "*.mod.zip" -exec cp {} release-files/ \;
            echo "ModI18N files copied"
          fi
          
          echo "=== Release files ==="
          ls -la release-files/

      - name: Get current date
        id: date
        shell: bash
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT

      - name: Create unified release
        uses: softprops/action-gh-release@v1
        with:
          files: release-files/*
          name: CoT ModLoader ${{ env.VERSION }}
          tag_name: ${{ env.VERSION }}
          body: |
            ## Course of Temptation ModLoader Release
            
            **Game Version:** ${{ env.VERSION }}
            **ModLoader Version:** ${{ env.MODLOADER_VERSION }}
            **Build Date:** ${{ steps.date.outputs.date }}
            
            ### ğŸ“¦ åŒ…å«å†…å®¹
            
            #### HTML ç‰ˆæœ¬
            - `CoT-ModLoader-v*-v*.zip` - åŒ…å«æ ‡å‡†ç‰ˆå’Œå…¼å®¹ç‰ˆ HTML
            
            #### Android APK
            - `CoT-ModLoader-*.apk` - æ ‡å‡†ç‰ˆ APK
            - `CoT-ModLoader-*-polyfill.apk` - å…¼å®¹ç‰ˆ APK
            
            âš ï¸ APK ä½¿ç”¨ debug ç­¾åï¼Œå¯èƒ½éœ€è¦å…ˆå¸è½½åŸç‰ˆåº”ç”¨å†å®‰è£…
            
            #### åŸç‰ˆå›¾åŒ…
            - `GameOriginalImagePack-*.mod.zip` - åŸç‰ˆæ¸¸æˆå›¾ç‰‡åŒ…
            
            éœ€è¦ ModLoader DoL ImageLoaderHook æ‰èƒ½ä½¿ç”¨å›¾ç‰‡åŒ…
            
            #### æ±‰åŒ–åŒ…
            - `ModI18N-*.mod.zip` - ä¸­æ–‡æ±‰åŒ–åŒ…ï¼ˆå¦‚æœå¯ç”¨ï¼‰
          prerelease: true